**깊은 복사(Deep Copy)**, **얕은 복사(Shallow Copy)**, **동적 할당(재할당)**은 데이터를 다룰 때 중요한 개념입니다. 각각의 정의와 차이점을 명확히 이해하면 메모리 관리와 데이터 처리에서 실수를 줄일 수 있습니다.

---

### **1. 얕은 복사 (Shallow Copy)**
- **정의**:  
  - 객체의 **최상위 레벨만 복사**합니다.  
  - 내부에 중첩된 객체나 배열은 **참조(주소)를 공유**합니다.  
- **특징**:  
  - 복사된 객체와 원본 객체가 **내부 데이터를 공유**합니다.  
  - 내부 데이터를 수정하면 원본과 복사본 모두 영향을 받습니다.  
- **사용 사례**:  
  - 간단한 객체 복사 시 사용.  
  - 성능이 중요할 때 (깊은 복사보다 빠름).  

#### 예제 (JavaScript)
```javascript
const original = { a: 1, b: { c: 2 } };
const shallowCopy = { ...original }; // 스프레드 연산자로 얕은 복사

shallowCopy.a = 10; // 최상위 레벨만 변경
shallowCopy.b.c = 20; // 내부 객체는 원본과 공유

console.log(original); // { a: 1, b: { c: 20 } }
console.log(shallowCopy); // { a: 10, b: { c: 20 } }
```

---

### **2. 깊은 복사 (Deep Copy)**
- **정의**:  
  - 객체의 **모든 레벨을 재귀적으로 복사**합니다.  
  - 내부에 중첩된 객체나 배열도 **새로운 메모리 공간에 복사**됩니다.  
- **특징**:  
  - 복사된 객체와 원본 객체가 **완전히 독립적**입니다.  
  - 내부 데이터를 수정해도 원본에 영향을 주지 않습니다.  
- **사용 사례**:  
  - 복잡한 객체를 완전히 복사해야 할 때.  
  - 원본 데이터를 보존해야 할 때.  

#### 예제 (JavaScript)
```javascript
const original = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(original)); // 깊은 복사

deepCopy.a = 10; // 최상위 레벨 변경
deepCopy.b.c = 20; // 내부 객체도 독립적

console.log(original); // { a: 1, b: { c: 2 } }
console.log(deepCopy); // { a: 10, b: { c: 20 } }
```

---

### **3. 동적 할당 (재할당)**
- **정의**:  
  - 변수에 새로운 값을 할당하거나, 메모리를 동적으로 할당/해제하는 것.  
  - JavaScript에서는 **가비지 컬렉션(Garbage Collection)**이 자동으로 메모리를 관리합니다.  
- **특징**:  
  - 변수에 새로운 값을 할당하면 **이전 값은 메모리에서 해제**됩니다.  
  - 객체나 배열의 경우, 참조가 끊기면 가비지 컬렉터가 메모리를 회수합니다.  
- **사용 사례**:  
  - 변수 값을 업데이트할 때.  
  - 메모리 효율성을 높일 때.  

#### 예제 (JavaScript)
```javascript
let a = 10;
a = 20; // 재할당 (이전 값 10은 메모리에서 해제됨)

let obj = { x: 1 };
obj = { y: 2 }; // 재할당 (이전 객체 { x: 1 }은 메모리에서 해제됨)
```

---

### **4. 차이점 요약**
| 구분 | 얕은 복사 (Shallow Copy) | 깊은 복사 (Deep Copy) | 동적 할당 (재할당) |
|------|--------------------------|-----------------------|--------------------|
| **복사 방식** | 최상위 레벨만 복사 | 모든 레벨을 재귀적으로 복사 | 새로운 값을 할당 |
| **메모리 공유** | 내부 데이터 공유 | 완전히 독립적 | 이전 값은 메모리 해제 |
| **성능** | 빠름 | 느림 | 빠름 |
| **사용 사례** | 간단한 객체 복사 | 복잡한 객체 복사 | 변수 값 업데이트 |

---

### **5. 주의사항**
1. **얕은 복사의 함정**:  
   - 내부 데이터를 수정하면 원본도 변경됩니다.  
   ```javascript
   const original = { a: { b: 1 } };
   const copy = { ...original };
   copy.a.b = 2;
   console.log(original.a.b); // 2
   ```

2. **깊은 복사의 한계**:  
   - `JSON.parse(JSON.stringify())`는 함수, `undefined`, 순환 참조를 처리하지 못합니다.  
   - 라이브러리(예: Lodash의 `_.cloneDeep`)를 사용하면 더 안전하게 깊은 복사를 할 수 있습니다.  

3. **재할당과 가비지 컬렉션**:  
   - 더 이상 참조되지 않는 객체는 자동으로 메모리에서 해제됩니다.  
   ```javascript
   let obj = { a: 1 };
   obj = null; // 이전 객체 { a: 1 }은 가비지 컬렉션 대상
   ```

---

### **6. 예제 코드**
#### 1) **얕은 복사 vs 깊은 복사**
```javascript
const original = { a: 1, b: { c: 2 } };

// 얕은 복사
const shallowCopy = { ...original };
shallowCopy.b.c = 20;
console.log(original.b.c); // 20 (원본도 변경됨)

// 깊은 복사
const deepCopy = JSON.parse(JSON.stringify(original));
deepCopy.b.c = 30;
console.log(original.b.c); // 20 (원본은 변경되지 않음)
```

#### 2) **재할당**
```javascript
let obj = { x: 1 };
obj = { y: 2 }; // 재할당
console.log(obj); // { y: 2 }
```

---

### **7. 백엔드 개발자를 위한 팁**
- **데이터베이스 조회 결과**를 수정할 때는 **깊은 복사**를 사용해 원본 데이터를 보존하세요.  
- **캐시(Cache)**나 **세션(Session)** 데이터를 다룰 때는 **얕은 복사**를 활용해 성능을 높일 수 있습니다.  
- **메모리 누수(Memory Leak)**를 방지하려면 불필요한 참조를 제거하세요.

